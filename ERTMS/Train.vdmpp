class Train	
types
	public State = <Running> | <Stopped> | <Finished>;
	public TrainLogEntry :: id : seq of char
													state : State
													posX : real
													posY : real

instance variables
	private posX : real;
	private posY : real;
	private currentTrack : nat;
	private route : map nat to Interlocking`Track;
	private transponders : map Interlocking`Track to Eurobalise;
	private rbc : RadioBlockCenter;
	private movementAuths : map Interlocking`Track to bool;
	private speed : real := 0;
	private started : bool := false;
	private id : seq of char := "";
	private state: State := <Stopped>;
	
	private routeNo: nat := 0;
	private timetable: map nat to Interlocking`Route;
	private trainLog: seq of TrainLogEntry;
	--private currentRoute: Interlocking`Route;
	
	inv forall x in set {1, ..., card dom route-1}
	 & InvTrackIsConnected(route(x),route(x+1));
	inv card dom route = card dom transponders;
	inv forall tr in set rng route &
	 tr.startX > 0 and tr.startY > 0 and tr.endX > 0 and tr.endY > 0;
	inv started = true and speed >= 0 or started = false and speed = 0;
	inv speed <= route(currentTrack).maxSpeed;
	
operations
	public Step: () ==> ()
	Step() ==
	( 
	    Drive();
	 );
	 
	 private Move: () ==> ()
	 Move() ==
	 (
		if (state = <Running> and routeNo < card dom timetable) then (
			UpdateStats(id, state, posX, posY);
			if(rbc.RequestMovementAuthority(timetable(routeNo)) = <MovementAuthorityGranted>)
			then (
					dcl currentRoute : Interlocking`Route := timetable(1);
					UpdateStats(id, state, posX, posY);
					for track in GetTracksInRoute(currentRoute) do (
						dcl currentEb : Eurobalise := transponders(track);
						currentEb.Enter();
						speed := track.maxSpeed;
						posX := track.endX;
						posY := track.endY;
						UpdateStats(id, state, posX, posY);
					)	
			) else (
				state := <Stopped>;
				UpdateStats(id, state, posX, posY);
			)
		) else UpdateStats(id, state, posX, posY);
	 );
	 
	 private UpdateStats: seq of char * State * real * real ==> ()
	 UpdateStats(id, state, posX, posY) ==
	 	trainLog := trainLog ^ [mk_TrainLogEntry(id, state, posX, posY)];
	 	
	 public GetStats: () ==> seq of TrainLogEntry
	 GetStats() ==
	 	return trainLog;
	 	
	pure public GetTracksInRoute: Interlocking`Route ==> seq of Interlocking`Track
	GetTracksInRoute(rt) ==
		if (card rt > 0) then
		(
			dcl trs : seq of Interlocking`Track := [];
			for all tr in set rt do
				trs := trs ^ [tr];
			return trs;
		) else return [];
	
	private Drive: () ==> ()
	Drive() ==
	-- Drive() performs one iteration of moving the train
	( -- continue if there is track to traverse
		if(currentTrack <= card dom route and started) then
		(
			dcl currentEb : Eurobalise := transponders(route(currentTrack));
			dcl distX : real := route(currentTrack).endX-posX;
			dcl distY : real := route(currentTrack).endY-posY;
			-- make sure we have MoA for current track
			if (movementAuths(route(currentTrack))) then (
				-- check where the train is currently
				if (posX = route(currentTrack).startX and posY = route(currentTrack).startY)
				then (
					-- enter track and drive halfway
					currentEb.Enter();
					if (distX = 0 and distY <> 0) then ( posY := posY + distY/2; )
					else if (distY = 0 and distX <> 0) then ( posX := posX + distX/2; )
					else if (distY <> 0 and distX <> 0) then
					( posY := posY + distY/2; posX := posX + distX/2; );
				) else if (posX = route(currentTrack).endX and posY = route(currentTrack).endY)
				then (
					-- leave current track, adjust speed to next track
					currentEb.Leave();
					if(currentTrack+1 < card dom route) then
					atomic (
						speed := route(currentTrack+1).maxSpeed;
						currentTrack := currentTrack+1;
					) else
						speed := 0;
				) else (
					-- we are midway. request MoA for next track, if there is such
					if (card dom route > currentTrack) then (
						if(rbc.RequestMovementAuthority(route(currentTrack+1)) = <MovementAuthorityGranted>)
						 then ( movementAuths := movementAuths ++ {route(currentTrack) |-> true}; )
					);
					-- drive the remaining way
					if (distX = 0 and distY <> 0) then ( posY := posY + distY; )
					else if (distY = 0 and distX <> 0) then ( posX := posX + distX; )
					else if (distX <> 0 and distY <> 0) then
					( posY := posY + distY; posX := posX + distX; );
				);
			) else (
				-- get MoA for current track
				if(rbc.RequestMovementAuthority(route(currentTrack)) = <MovementAuthorityGranted>)
				then (
					movementAuths := movementAuths ++ {route(currentTrack) |-> true};
					started := true;
				) else (
				-- could not get MoA. Stopping ...
					speed := 0;
				)
			)
		) else (
			-- train has reached end of route, stop
			speed := 0; started := false
		)
	);
			
	public Start: () ==> ()
	Start() ==
		started := true;
		
	public Stop: () ==> ()
	Stop() ==
		started := false;
	
	public GetPosX: () ==> real
	GetPosX() ==
		return posX;
		
	public GetPosY: () ==> real
	GetPosY() ==
		return posY;
	
	public GetSpeed: () ==> real
	GetSpeed() ==
		return speed;
	
	public GetId: () ==> seq of char
	GetId() ==
		return id;
		
	public GetTrack: () ==> Interlocking`Track
	GetTrack() ==
		return route(currentTrack);
		
	public IsStarted: () ==> bool
	IsStarted() ==
		return started;
		
	public GetMovementAuths: () ==> set of Interlocking`Track
	GetMovementAuths() ==
		return {tr | tr in set dom movementAuths & movementAuths(tr) = true};
		
	public Train: map nat to Interlocking`Track
	* map Interlocking`Track to Eurobalise * RadioBlockCenter * seq of char ==> Train
	 Train(rtmap,trans,prbc, pid) ==
	 atomic (
	 	posX := rtmap(1).startX;
	 	posY := rtmap(1).startY;
	 	currentTrack := 1;
	 	route := rtmap;
	 	transponders := trans;
	 	rbc := prbc;
	 	movementAuths := {x |-> false | x in set rng rtmap};
	 	id := pid;
	 );
	 
functions
	public InvTrackIsConnected: Interlocking`Track * Interlocking`Track -> bool
	InvTrackIsConnected(tr1, tr2) ==
		tr1.endX = tr2.startX and tr1.endY = tr2.startY;
		
end Train