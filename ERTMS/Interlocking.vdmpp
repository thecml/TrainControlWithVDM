class Interlocking

types
	public ProceedMessage = <PROCEED_GRANTED> | <PROCEED_DENIED>;
	public Track :: startX : nat
									startY : nat
									endX : nat
									endY : nat
									description : seq of char
									maxSpeed : nat;
	public Route = set of Track;
	public RouteRequest :: rbc : RadioBlockCenter
												 rt : Route
										
instance variables
	private trackOccupied : map Track to bool; -- physically occupied track
	private avaliableRoutes : set of Route; -- routes not planned to be occupied
	private radioBlockCenters : map Route to RadioBlockCenter;
	
	inv card avaliableRoutes < 2 or forall rt in set avaliableRoutes & InvNoDuplicateTrack(rt);
	inv card avaliableRoutes = card dom trackOccupied;
		
operations
	public RequestToProceed: Route ==> ProceedMessage
	RequestToProceed(rt) ==
		-- if route is in avaliableRoutes and the tracks in the route are not in the doms of trackOccupied
			-- grant proceed by returning true
		-- else return false
		if(rt in set avaliableRoutes
		 and forall tr in set rt & trackOccupied(tr) = false)
		then return <PROCEED_GRANTED>
		else return <PROCEED_DENIED>
	pre card rt > 0;

	public RequestRoute: (Route) ==> ()
	RequestRoute(rt) ==
		-- if route is not in routesAvaliable and the tracks are not occupied already,
		-- then add it to routesAvaliable and inform RBC.
		-- else do nothing				
		if (rt not in set avaliableRoutes and forall tr in set rt & trackOccupied(tr) = false)
		then (		
			avaliableRoutes := avaliableRoutes union {rt};
			radioBlockCenters(rt).SetRouteAsAvailable(rt)
		) else skip;

	public SetTrackState: Track * Eurobalise`TrainState ==> ()
		SetTrackState(tr, sta) ==
		-- set specific track as occupied if train enters.
		-- if train leaves, clear track and inform RBC.
			if(sta = <TRAIN_ENTER>)
			then trackOccupied(tr) := true
			else if (sta = <TRAIN_LEAVE>)
			then ( trackOccupied := trackOccupied ++ {tr|->false};
			radioBlockCenters({tr}).SetRouteAsAvailable({tr});
			);
			
	public GetAvaliableRoutes: () ==> set of Route
	GetAvaliableRoutes() ==
		--return all avaliable routes
		return avaliableRoutes;
		
	public Interlocking: set of Route * seq of RadioBlockCenter ==> Interlocking
	Interlocking(rts, rbcs) ==
		 atomic (
			avaliableRoutes := rts;
			trackOccupied :=  {let tr in set i in tr |-> false | i in set rts};
			radioBlockCenters := {rbc.GetResponsibleTracks() |-> rbc | rbc in seq rbcs}
		);

functions
	public InvNoDuplicateTrack: Route -> bool
	InvNoDuplicateTrack(rt) ==
		forall tr1, tr2 in set rt & tr1 <> tr2 => tr1 <> tr2;
				
	public InvIsTrackOccupied: Route * map Track to bool -> bool
	InvIsTrackOccupied(rt,trmap) ==
		forall i in set rt & trmap(i) <> false
		pre card rt > 0;
		
end Interlocking