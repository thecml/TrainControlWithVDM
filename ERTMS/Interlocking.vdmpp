class Interlocking

types
	public Message = <PROCEED_GRANTED> | <PROCEED_DENIED>;
	public ProceedReply :: Message
												 routesAvaliable : set of Route;
													 
	public Track :: startX : nat
									startY : nat
									endX : nat
									endY : nat
									description : seq of char
									maxSpeed : nat;
	public Route = set of Track;
	public RouteRequest :: rbc : RadioBlockCenter
												 rt : Route
										
instance variables
	private occupiedTracks : map Track to bool; -- physically occupied track
	private avaliableRoutes : set of Route; -- routes not planned to be occupied
	
	inv card avaliableRoutes < 2 or InvNoDuplicateTrack(avaliableRoutes);
	inv forall rt in set avaliableRoutes & forall tr in set rt
		& tr not in set dom occupiedTracks or occupiedTracks(tr) = false;
		
operations
	public RequestToProceed: Route ==> ProceedReply
	RequestToProceed(rt) ==
		-- if route is in avaliableRoutes and the tracks in the route are not in the doms of trackOccupied
			-- grant proceed by returning true
		-- else return false
		if(rt in set avaliableRoutes
		 and forall tr in set rt & occupiedTracks(tr) = false)
		then return mk_ProceedReply(<PROCEED_GRANTED>, avaliableRoutes)
		else return mk_ProceedReply(<PROCEED_DENIED>, avaliableRoutes)
	pre card rt > 0;

	public RequestRoute: (Route) ==> ()
	RequestRoute(rt) ==
		-- if route is not in routesAvaliable and the tracks are not occupied already,
		-- then add it to routesAvaliable
		-- else do nothing				
		if (rt not in set avaliableRoutes and
			forall tr in set rt & tr not in set dom occupiedTracks
				or occupiedTracks(tr) = false)
		then (		
			avaliableRoutes := avaliableRoutes union {rt};
			let tr in set rt
			in
				occupiedTracks := occupiedTracks ++ {tr |-> false}
		) else skip;

	public SetTrackState: Track * Eurobalise`TrainState ==> ()
		SetTrackState(tr, sta) ==
		-- set specific track as occupied if train enters.
		-- if train leaves, clear track and inform RBC.
		if(sta = <TRAIN_ENTER>)
			then occupiedTracks(tr) := true
		else if (sta = <TRAIN_LEAVE>)
			then (
				occupiedTracks := occupiedTracks ++ {tr|->false};
			)
		pre tr in set dom occupiedTracks;
			
	public GetAvaliableRoutes: () ==> set of Route
	GetAvaliableRoutes() ==
		--return all avaliable routes
		return avaliableRoutes;
	
	public GetOccupiedTracks : () ==> set of Track
	GetOccupiedTracks() ==
	(
		return {tr | tr in set dom occupiedTracks
			& occupiedTracks(tr) = true};
	);
	
	public Interlocking: set of Route ==> Interlocking
	Interlocking(rts) ==
		 atomic (
			avaliableRoutes := rts;
			occupiedTracks :=  {let tr in set i in tr |-> false | i in set rts};
		 );

functions
	public InvNoDuplicateTrack: set of Route -> bool
	InvNoDuplicateTrack(srt) ==
	-- a route cannot contain the same track twice,
	-- but two routes can contain the same track
		forall rt1 in set srt &
		  forall tr1,tr2 in set rt1 & tr1 <> tr2
		 		=> tr1.startX <> tr2.startX or tr1.endX <> tr2.endX 
		 		or tr1.startY <> tr2.startY or tr1.endY <> tr2.endY;
				
	public InvIsTrackOccupied: Route * map Track to bool -> bool
	InvIsTrackOccupied(rt,trmap) ==
		forall i in set rt & trmap(i) <> false
		pre card rt > 0;
		
end Interlocking