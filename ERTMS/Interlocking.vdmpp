class Interlocking

values
tracks = {mk_Track(10,5,15,5,"AB",100),
	mk_Track(15,5,20,5,"BC",110),
	mk_Track(20,5,25,5,"CD",110),
	mk_Track(25,5,30,5,"DE",110),
	mk_Track(25,5,30,5,"EF",110)};
routes = {tracks};

types
	public Order = <PROCEED_GRANTED> | <PROCEED_DENIED>;
	public ProceedReply :: message : Order
												 routesAvaliable : set of Route;						 
	public Track :: startX : nat
									startY : nat
									endX : nat
									endY : nat
									description : seq of char
									maxSpeed : nat;
	public Route = set of Track;
	public RouteRequest :: rbc : RadioBlockCenter
												 rt : Route
										
instance variables
	private trackTable : map Track to bool; -- track table with physical state of track
	private availableRoutes : set of Route; -- routes not planned to be occupied
	
	inv InvNoDuplicateTrack(availableRoutes);
	inv InvNoTrackAvailableAndOccupied(trackTable, availableRoutes);
	
operations
	public RequestToProceed: Route ==> ProceedReply
	RequestToProceed(prt) ==
		-- if route is in avaliableRoutes and the route tracks are not in the dom of trackOccupied
			-- grant proceed by returning true, else return false
		if (card availableRoutes > 0) then (
			if(exists rt in set availableRoutes
			 & prt subset rt and forall tr in set prt
			  & tr in set dom trackTable) then
					if(forall tr in set prt & trackTable(tr) = false) then (
						availableRoutes := availableRoutes \ {prt};
						return mk_ProceedReply(<PROCEED_GRANTED>, availableRoutes)
					)
					else
						return mk_ProceedReply(<PROCEED_DENIED>, availableRoutes)
			else return mk_ProceedReply(<PROCEED_DENIED>, availableRoutes)
			) else (
				return mk_ProceedReply(<PROCEED_DENIED>, availableRoutes);
			)
	pre card prt > 0;

	public RequestRoute: (Route) ==> ()
	RequestRoute(rt) ==
		-- if route is not in routesAvaliable and the tracks are not occupied ,
		-- then add it to routesAvaliable and clear trackTable -- else do nothing				
		if (rt not in set availableRoutes and
			forall tr in set rt & tr not in set dom trackTable
				or trackTable(tr) = false)
					then (
						atomic (		
							availableRoutes := availableRoutes union {rt};
							trackTable := trackTable ++ {let tr in set rt in tr |-> false}
						)
					) else skip;

	public SetTrackState: Track * Eurobalise`TrainState ==> ()
		SetTrackState(tr, sta) ==
		-- if train enters, set specific track as occupied
		-- if train leaves, clear track
		if(sta = <TRAIN_ENTER>) then
				trackTable := trackTable ++ {tr |-> true}
		else if (sta = <TRAIN_LEAVE>) then
				trackTable := trackTable ++ {tr|->false}
		post tr in set dom trackTable;
			
	pure public GetAvaliableRoutes: () ==> set of Route
	GetAvaliableRoutes() ==
		return availableRoutes;
		
	pure public GetAvaliableRoutes: set of Track ==> set of Route
	GetAvaliableRoutes(trs) ==
		return (availableRoutes inter {trs});
	
	pure public GetTrackTable : () ==> set of Track
	GetTrackTable() ==
	(
		return {tr | tr in set dom trackTable & trackTable(tr) = true};
	);
	
	public Interlocking: set of Route ==> Interlocking
	Interlocking(rts) ==
		atomic (
			availableRoutes := rts;
			trackTable := { tr |-> false | tr in set GetTracksInRoutes(rts)};
		 );
		 
	pure public GetTracksInRoutes: set of Route ==> set of Track
	GetTracksInRoutes(rts) ==
		if (card rts > 0) then
		(
			dcl trs : set of Track := {};
			for all rt in set rts do
				for all tr in set rt do
					trs := trs union {tr};
			return trs;
		) else return {};
		
functions
	public InvNoTrackAvailableAndOccupied: map Track to bool * set of Route -> bool
	InvNoTrackAvailableAndOccupied(trmap, rts) ==
	-- A track cannot be available and occupied.
	forall rt in set rts & forall tr in set rt
		& tr not in set dom trmap or trmap(tr) = false;
	
	public InvNoDuplicateTrack: set of Route -> bool
	InvNoDuplicateTrack(srt) ==
	-- a route cannot contain the same track twice,
	-- but two routes can contain the same track
	forall rt1 in set srt &
	  forall tr1,tr2 in set rt1 & tr1 <> tr2
	 		=> tr1.startX <> tr2.startX or tr1.endX <> tr2.endX 
	 		or tr1.startY <> tr2.startY or tr1.endY <> tr2.endY;
				
	public InvIsTrackOccupied: Route * map Track to bool -> bool
	InvIsTrackOccupied(rt,trmap) ==
		exists i in set rt & if i in set dom trmap
		 then (trmap(i) = true) else false
	pre card rt > 0

traces
T1: let trmap in set {{mk_Track(10,5,15,5,"AB",100) |-> false}} in
			InvNoTrackAvailableAndOccupied(trmap, routes);

T2: let trmap in set {{mk_Track(10,5,15,5,"AB",100) |-> true}} in
			InvNoTrackAvailableAndOccupied(trmap, routes);
			
T3: let trmap in set {{mk_Track(90,5,90,5,"XX",100) |-> true}} in
			InvNoTrackAvailableAndOccupied(trmap, routes);
			
T4: InvNoDuplicateTrack(routes);

T5: let rts in set {{{mk_Track(5,5,10,5,"AB",100),
			 mk_Track(2,5,10,5,"BA",100)},
			  {mk_Track(20,5,10,5,"AB",100),
			   mk_Track(30,5,10,5,"DE",100)}}} in
					InvNoDuplicateTrack(rts);

T6: let rts in set {{{mk_Track(5,5,10,5,"AB",100),
			 mk_Track(5,5,10,5,"BA",100)},
			  {mk_Track(5,5,10,5,"CD",100),
			   mk_Track(5,5,10,5,"DE",100)}}} in
					InvNoDuplicateTrack(rts);

T7: let rt in set {{mk_Track(10,5,15,5,"AB",100), mk_Track(15,5,20,5,"BC",100)},
				{mk_Track(20,5,25,5,"AB",100), mk_Track(25,5,30,5,"DE",100)}} in
					let trmap = {mk_Track(10,5,15,5,"AB",100) |-> false} in
						InvIsTrackOccupied(rt, trmap);
					
T8: let rt in set {{mk_Track(10,5,15,5,"AB",100), mk_Track(15,5,20,5,"BC",100)},
				{mk_Track(20,5,25,5,"CD",100), mk_Track(25,5,30,5,"DE",100)}} in
					let trmap = {mk_Track(25,5,30,5,"DE",100) |-> true} in
						InvIsTrackOccupied(rt, trmap);
					
T9: let trmap = {mk_Track(10,5,15,5,"AB",100) |-> false} in
					InvIsTrackOccupied({}, trmap);


end Interlocking