class Interlocking

values
tracks = {mk_Track(10,5,15,5,"AB",100),
	mk_Track(15,5,20,5,"BC",110),
	mk_Track(20,5,25,5,"CD",110),
	mk_Track(25,5,30,5,"DE",110),
	mk_Track(25,5,30,5,"EF",110)};
routes = {tracks};

types
	public Order = <PROCEED_GRANTED> | <PROCEED_DENIED>;
	public ProceedReply :: message : Order
												 routesAvaliable : set of Route;						 
	public Track :: startX : nat
									startY : nat
									endX : nat
									endY : nat
									description : seq of char
									maxSpeed : nat;
	public Route = set of Track;
	public RouteRequest :: rbc : RadioBlockCenter
												 rt : Route
										
instance variables
	private occupiedTracks : map Track to bool; -- physically occupied track
	private availableRoutes : set of Route; -- routes not planned to be occupied
	
	inv card availableRoutes < 2 or InvNoDuplicateTrack(availableRoutes);
	inv InvNoTrackAvailableAndOccupied(occupiedTracks, availableRoutes);
	
operations
	public RequestToProceed: Route ==> ProceedReply
	RequestToProceed(prt) ==
		-- if route is in avaliableRoutes and the route tracks are not in the dom of trackOccupied
			-- grant proceed by returning true, else return false
		if (card availableRoutes > 0) then (
			let rt in set availableRoutes in
				if(prt subset rt and forall tr in set prt & occupiedTracks(tr) = false)
					then return mk_ProceedReply(<PROCEED_GRANTED>, availableRoutes)
			else return mk_ProceedReply(<PROCEED_DENIED>, availableRoutes)
			) else (
				return mk_ProceedReply(<PROCEED_DENIED>, availableRoutes);
			)
	pre card prt > 0;

	public RequestRoute: (Route) ==> ()
	RequestRoute(rt) ==
		-- if route is not in routesAvaliable and the tracks are not occupied ,
		-- then add it to routesAvaliable and clear occupiedTracks -- else do nothing				
		if (rt not in set availableRoutes and
			forall tr in set rt & tr not in set dom occupiedTracks
				or occupiedTracks(tr) = false)
		then (
			atomic (		
				availableRoutes := availableRoutes union {rt};
				occupiedTracks := occupiedTracks ++ {let tr in set rt in tr |-> false}
			)
		) else skip;

	public SetTrackState: Track * Eurobalise`TrainState ==> ()
		SetTrackState(tr, sta) ==
		-- set specific track as occupied if train enters.
		-- if train leaves, clear track
		if(sta = <TRAIN_ENTER>) then (
		atomic (
				occupiedTracks(tr) := true;
				availableRoutes := {rt | rt in set availableRoutes & rt inter {tr} = {}};
				)
			)
		else if (sta = <TRAIN_LEAVE>) then (
		atomic (
				occupiedTracks := occupiedTracks ++ {tr|->false};
				availableRoutes := availableRoutes union {{tr}};
				)
			)
		pre tr in set dom occupiedTracks;
			
	public GetAvaliableRoutes: () ==> set of Route
	GetAvaliableRoutes() ==
		return availableRoutes;
		
	public GetAvaliableRoutes: set of Track ==> set of Route
	GetAvaliableRoutes(trs) ==
		return (availableRoutes inter {trs});
	
	public GetOccupiedTracks : () ==> set of Track
	GetOccupiedTracks() ==
	(
		return {tr | tr in set dom occupiedTracks & occupiedTracks(tr) = true};
	);
	
	public Interlocking: set of Route ==> Interlocking
	Interlocking(rts) ==
		atomic (
			availableRoutes := rts;
			occupiedTracks := { tr |-> false | tr in set GetTracksInRoute(rts)};
		 )

functions
	public GetTracksInRoute: set of Route -> set of Track
	GetTracksInRoute(rts) ==
	(
		if (card rts > 0) then (let rt in set rts in rt) else {}
	);
	
	public InvNoTrackAvailableAndOccupied: map Track to bool * set of Route -> bool
	InvNoTrackAvailableAndOccupied(trmap, rts) ==
	-- A track cannot be available and occupied.
	forall rt in set rts & forall tr in set rt
		& tr not in set dom trmap or trmap(tr) = false;
	
	public InvNoDuplicateTrack: set of Route -> bool
	InvNoDuplicateTrack(srt) ==
	-- a route cannot contain the same track twice,
	-- but two routes can contain the same track
	forall rt1 in set srt &
	  forall tr1,tr2 in set rt1 & tr1 <> tr2
	 		=> tr1.startX <> tr2.startX or tr1.endX <> tr2.endX 
	 		or tr1.startY <> tr2.startY or tr1.endY <> tr2.endY;
				
	public InvIsTrackOccupied: Route * map Track to bool -> bool
	InvIsTrackOccupied(rt,trmap) ==
		exists i in set rt & if i in set dom trmap
		 then (trmap(i) = true) else false
	pre card rt > 0

traces
T1: let trmap in set {{mk_Track(10,5,15,5,"AB",100) |-> false}} in
			InvNoTrackAvailableAndOccupied(trmap, routes);

T2: let trmap in set {{mk_Track(10,5,15,5,"AB",100) |-> true}} in
			InvNoTrackAvailableAndOccupied(trmap, routes);
			
T3: let trmap in set {{mk_Track(90,5,90,5,"XX",100) |-> true}} in
			InvNoTrackAvailableAndOccupied(trmap, routes);
			
T4: InvNoDuplicateTrack(routes);

T5: let rts in set {{{mk_Track(5,5,10,5,"AB",100),
			 mk_Track(2,5,10,5,"BA",100)},
			  {mk_Track(20,5,10,5,"AB",100),
			   mk_Track(30,5,10,5,"DE",100)}}} in
					InvNoDuplicateTrack(rts);

T6: let rts in set {{{mk_Track(5,5,10,5,"AB",100),
			 mk_Track(5,5,10,5,"BA",100)},
			  {mk_Track(5,5,10,5,"CD",100),
			   mk_Track(5,5,10,5,"DE",100)}}} in
					InvNoDuplicateTrack(rts);

T7: let rt in set {{mk_Track(10,5,15,5,"AB",100), mk_Track(15,5,20,5,"BC",100)},
				{mk_Track(20,5,25,5,"AB",100), mk_Track(25,5,30,5,"DE",100)}} in
					let trmap = {mk_Track(10,5,15,5,"AB",100) |-> false} in
						InvIsTrackOccupied(rt, trmap);
					
T8: let rt in set {{mk_Track(10,5,15,5,"AB",100), mk_Track(15,5,20,5,"BC",100)},
				{mk_Track(20,5,25,5,"CD",100), mk_Track(25,5,30,5,"DE",100)}} in
					let trmap = {mk_Track(25,5,30,5,"DE",100) |-> true} in
						InvIsTrackOccupied(rt, trmap);
					
T9: let trmap = {mk_Track(10,5,15,5,"AB",100) |-> false} in
					InvIsTrackOccupied({}, trmap);


end Interlocking