class RadioBlockCenter
types
	public MovementAuthorityReply = <MovementAuthorityGranted> | <MovementAuthorityDenied>;
	
values
tracks = {mk_Interlocking`Track(10,5,15,5,"AB",100),
	mk_Interlocking`Track(15,5,20,5,"BC",110),
	mk_Interlocking`Track(20,5,25,5,"CD",110),
	mk_Interlocking`Track(25,5,30,5,"DE",110),
	mk_Interlocking`Track(25,5,30,5,"EF",110)}

instance variables
	private responsibleTracks : set of Interlocking`Track;
	private availableRoutes : set of Interlocking`Route; -- from interlocking
	private movementAuthorites : map nat to seq of Interlocking`Track;
	private itl : Interlocking;
	
	inv card availableRoutes < 2 or Interlocking`InvNoDuplicateTrack(availableRoutes);

operations	
	public RequestMovementAuthority: Interlocking`Track ==> MovementAuthorityReply
	RequestMovementAuthority(tr) ==
		let rt in set availableRoutes in
			if(tr in set responsibleTracks and tr in set rt)
			then (
				dcl msg : Interlocking`Order;
				def mk_Interlocking`ProceedReply(message,rtr) = itl.RequestToProceed({tr})
				in
				( msg := message; availableRoutes := rtr; );
				if (msg = <PROCEED_GRANTED>)
				then (
					return <MovementAuthorityGranted>;
				) else (
					availableRoutes := {rt | art in set availableRoutes & art inter {tr} = {}};
					return <MovementAuthorityDenied>;
			)
		) else return <MovementAuthorityDenied>;
		
	private GetAvailableRoutesFromItl: () ==> ()
	GetAvailableRoutesFromItl() ==
		availableRoutes := itl.GetAvaliableRoutes(responsibleTracks);
		
	public GetAvailableRoutes: () ==> set of Interlocking`Route
	GetAvailableRoutes() ==
		return availableRoutes;
	
	public GetResponsibleTracks: () ==> set of Interlocking`Track
	GetResponsibleTracks() ==
		return responsibleTracks;
	
	public RadioBlockCenter : set of Interlocking`Route
	 * set of Interlocking`Track * Interlocking ==> RadioBlockCenter
	RadioBlockCenter(rts,trs,pitl) ==
	atomic (
		availableRoutes := rts;
		responsibleTracks := trs;
		itl := pitl;
		movementAuthorites := {|->};
	);
		
functions
	public IsTrackInSetOfTracks: Interlocking`Track * set of Interlocking`Track
	 -> bool
	IsTrackInSetOfTracks(tr,trs) ==
		tr in set trs
	pre card trs > 0;

	public IsTrackInRoute: Interlocking`Track * Interlocking`Route
	 -> bool
	IsTrackInRoute(tr, rt) ==
		forall rtt in set rt & tr = rtt
	pre card rt > 0;

	public IsTrackOccupied: Interlocking`Track * map Interlocking`Track to bool
	 -> bool
	IsTrackOccupied(tr,routemap) ==
		routemap(tr) = true
	pre tr in set dom routemap;

traces
T1: let tr in set tracks in
			let trs = tracks in
				IsTrackInSetOfTracks(tr, trs);

T2: let tr = mk_Interlocking`Track(25,5,30,10,"AB",100) in
			let trs = tracks in
				IsTrackInSetOfTracks(tr, trs);

T3: let tr in set tracks in
			IsTrackInRoute(tr, tracks);
			
T4: let tr = mk_Interlocking`Track(25,5,30,10,"AB",100) in
			IsTrackInRoute(tr, tracks);
		
T5: let tr in set tracks in
				IsTrackInRoute(tr, {}); 
				
T6: let tr in set tracks in
			let trmap = {mk_Interlocking`Track(10,5,15,5,"AB",100) |-> true} in
					IsTrackOccupied(tr, trmap);
			
T7: let tr in set tracks in
			let trmap = {mk_Interlocking`Track(10,5,15,5,"AB",100) |-> false} in
					IsTrackOccupied(tr, trmap);
					
end RadioBlockCenter